# 다형성(polymorphism)

## 다형성이란?

* 객체지향개념에서 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미한다.
* 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다.
* 이를 좀 더 구체적으로 말하면, **조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있도록 하였다.**

```java
class Tv {
    boolean power;
    int channel;
    
    void power() {}
    void channelUp() {}
    void channelDown() {}
}

class CaptionTv extends Tv {
    String text;
    
    void caption() {}
}

class Example {
    public static void main(String[] args){
        CaptionTv c = new CaptionTv();
        Tv t = new CaptionTv();
    }
}
```

* 이 경우 실제 인스턴스가 CaptionTv 타입이라 할지라도, 참조변수 t로는 CaptionTv 인스턴스의 모든 멤버를 사용할 수 없다.
* Tv 타입의 참조변수로는 CaptionTv 인스턴스 멤버 중에서 Tv 클래스의 멤버들만 사용할 수 있다.
* **둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버가 달라진다.**

![7-5-1](./images/7-5-1.png)

* 반대로 아래와 같이 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 가능할까?

```java
CaptionTv c = new Tv();
```

* 불가능하다. 그 이유는 실제 인스턴스인 Tv의 멤버 개수보다 참조변수 c가 사용할 수 있는 멤버 개수가 더 많기 때문이다.
* 참조변수 c로는 c가 참조하고 있는 인스턴스에서 text와 caption()을 사용하려 할 수 있다.
* 하지만 c가 참조하고 있는 인스턴스는 Tv 타입이고, Tv 인스턴스에는 text와 caption()이 존재하지 않기 때문에 문제가 발생한다.
* **자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 존재하지 않는 멤버를 사용할 가능성이 있으므로 허용하지 않는다.**

```
조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수 없다.
```

## 참조변수의 형변환

* 서로 상속관계에 있는 클래스사이에서만 참조변수도 형변환이 가능하다.
* 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에  
  참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다.
* 단지 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것 뿐이다.

```
자손타입 -> 조상타입 (Up-casting) : 형변환 생략가능
자손타입 <- 조상타입 (Down-casting) : 형변환 생략불가
```

```java
class Car {
    String color;
    int door;
    
    void drive() { System.out.println("drive"); }
    void stop() { System.out.println("stop"); }
}

class FireEngine extends Car {
    void water() { System.out.println("water"); }
}

class Example {
    public static void main(String[] args) {
        Car car;
        FireEngine fe = new FireEngine();
        
        fe.water();
        
        car = fe;               // 자손타입 -> 조상타입 (Up-casting)        
//      car.water();            // 컴파일 에러. Car 타입의 참조변수로는 water()를 호출할 수 없다.

        fe = (FireEngine)car;   // 자손타입 <- 조상타입 (Down-casting)
        fe.water();
    }
}
```

```
water
water
```

* **자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 존재하지 않는 멤버를 사용할 가능성이 있으므로 허용하지 않는다.**
* **조상타입의 참조변수를 자손타입의 참조변수로 형변환하는 down-casting이 가능하다.**
```
자손타입 참조변수 = 조상타입 참조변수 (O)
자손타입 참조변수 = 조상타입 인스턴스 (X)
```
* 위 두 문장이 햇갈릴 수도 있는데 아래의 예제를 보자.

```java
class Example {
    public static void main(String[] args) {
        Car car = new Car();
        FireEngine fe;
        
        fe = (FireEngine)car;
    }
}
```

* 두 번째 예제는 컴파일은 성공하지만, `fe = (FireEngine)car` 문장에서 런타임 에러가 발생한다.  
  첫 번째 예제의 `fe = (FireEngine)car` 문장과의 차이점을 생각해보자.

* 우선 위 문장은 **'조상타입의 참조변수를 자손타입의 참조변수로 형변환하는 down-casting이 가능하다'** 는 조건을 만족하고 있다.  
  그러나,

* 첫 번째 예제의 `fe = (FireEngine)car` 에서 car 참조변수는 FireEngine 인스턴스를 참조하고 있고,  
  두 번째 예제의 `fe = (FireEngine)car` 에서 car 참조변수는 Car 인스턴스를 참조하고 있다.
  
* 두 번째 예제는 **자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 불가능하다.** 는 조건을 만족하지 못한다.  
  따라서 두 번째 예제에서는 에러가 발생한다.

* 컴파일 에러가 아닌 런타임 에러가 발생하는 이유
  * 컴파일 타임에는 참조변수간의 타입만 체크하기 때문에 런타임에 car 참조변수가 실제로 참조하고 있을 인스턴스의 타입에  
    대해서는 전혀 알지 못한다. 그래서 컴파일 타임에는 에러가 발생하지 않는다.
  * 그러나 런타임에 자손타입 참조변수(fe)로 조상타입 인스턴스(Car)를 참조하게 되어 에러가 발생한다.

```java
class A {}
class B extends A {}
class C extends B {}
class D extends C {}

class Example {
    public static void main(String[] args) {
        A a;
        ...
        C c = (C)a;
        ...
    }
}
```
* `C c = (C)a;` 코드에서 조상타입의 참조변수를 자손타입의 참조변수로 형변환하고 있다. (down-casting)

* 런타임에 `C c = (C)a;` 코드에서 참조변수 a가 참조하고 있을 인스턴스는 A 혹은 자손인 B, C, D 인스턴스일 것이다.
  * **case 1 : 참조변수 a가 A or B 인스턴스를 참조하고 있는 경우**
    * C 타입 참조변수 c가 조상타입인 A 또는 B 인스턴스를 참조하게 되므로 런타임 에러가 발생한다.
  * **case 2 : 참조변수 a가 C or D 인스턴스를 참조하고 있는 경우**
    * C 타입 참조변수 c가 자신(C) 또는 자손타입인 D 인스턴스를 참조하게 되므로 런타임 에러가 발생하지 않는다.

* case 1 문제가 발생할 가능성이 있기 때문에 down-casting은 형변환을 생략할 수 없으며, 형변환을 수행하기 전에  
  instanceof 연산자를 사용해서 참조변수가 참조하고 있는 실제 인스턴스의 타입을 확인하는 것이 안전하다.
  
* 자손타입의 참조변수를 조상타입의 참조변수로 형변환하는 up-casting의 경우 ex) `a = c;`  
  조상타입 참조변수 a가 자손타입 인스턴스를 참조하게 될 것이라는 보장이 있기 때문에 형변환을 생략할 수 있다.

## instanceof 연산자

## 참조변수와 인스턴스의 연결

## 매개변수의 다형성

## 여러 종류의 객체를 배열로 다루기

# 참고
